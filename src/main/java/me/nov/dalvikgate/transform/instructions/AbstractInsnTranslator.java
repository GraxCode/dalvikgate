package me.nov.dalvikgate.transform.instructions;

import static me.nov.dalvikgate.asm.ASMCommons.*;
import static org.objectweb.asm.Type.*;

import java.util.HashMap;

import org.jf.dexlib2.builder.BuilderInstruction;
import org.jf.dexlib2.builder.Label;
import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;

import me.nov.dalvikgate.DexToASM;
import me.nov.dalvikgate.transform.instructions.exception.TranslationException;
import me.nov.dalvikgate.transform.instructions.unresolved.UnresolvedVarInsn;

public abstract class AbstractInsnTranslator<T extends BuilderInstruction> implements Opcodes {

  protected InstructionTransformer it;
  protected InsnList il;
  protected HashMap<BuilderInstruction, LabelNode> labels;

  public AbstractInsnTranslator(InstructionTransformer it) {
    this.it = it;
    this.il = it.il;
    this.labels = it.labels;
  }

  /**
   * Translates a DEX instruction to java bytecode and adds it to the list
   * 
   * @param list  The java bytecode instruction list
   * @param input The dex instruction
   */
  public abstract void translate(T input);

  /**
   * Get the assigned ASM LabelNode for a DEX label using the label map generated by {@link #buildLabels() buildLabels}. Multiple labels can have the same LabelNode.
   * 
   * @param label The label
   */
  public LabelNode toASMLabel(Label label) {
    return it.toASMLabel(label);
  }

  /**
   * Method to convert registers to labels, considering parameters and method visibility. Be aware that dalvik reuses unused registers.
   * 
   * @param register The register to be converted
   */
  protected int regToLocal(int register) {
    return it.regToLocal(register);
  }

  /**
   * Gets the next instruction, ignoring payloads
   */
  protected BuilderInstruction getNextOf(BuilderInstruction i) {
    return it.getNextOf(i);
  }

  /**
   * Add local set for object type.
   *
   * @param register Register index.
   */
  protected void addLocalSetObject(int register) {
    addLocalGetSet(true, register, OBJECT_TYPE);
  }

  /**
   * Add local set for the given type.
   *
   * @param register Register index.
   * @param type     Discovered type to put.
   */
  protected void addLocalSet(int register, Type type) {
    if (type.getSort() == ARRAY)
      type = ARRAY_TYPE;
    else if (type.getSort() == OBJECT)
      type = OBJECT_TYPE;
    else if (type.getSort() == VOID)
      throw new TranslationException("Illegal type 'void'");
    addLocalGetSet(true, register, type);
  }

  protected void addLocalSet(int register, boolean wide) {
    addLocalGetSet(true, register, null, wide);
  }

  /**
   * Add local set for potentially int type.
   *
   * @param register Register index.
   * @param value    Int value.
   */
  protected void addLocalSet(int register, int value) {
    if (value == 0)
      addLocalGetSet(true, register, null, false);
    else
      addLocalGetSet(true, register, INT_TYPE);
  }

  /**
   * Add local get for object type.
   *
   * @param register Register index.
   */
  protected void addLocalGetObject(int register) {
    addLocalGetSet(false, register, OBJECT_TYPE);
  }

  /**
   * Add local get for the given type.
   *
   * @param register Register index.
   * @param type     Discovered type to get.
   */
  protected void addLocalGet(int register, Type type) {
    if (type.getSort() == ARRAY)
      type = ARRAY_TYPE;
    else if (type.getSort() == OBJECT)
      type = OBJECT_TYPE;
    else if (type.getSort() == VOID)
      throw new TranslationException("Illegal type 'void'");
    addLocalGetSet(false, register, type);
  }

  /**
   * Add local get for unknown types.
   *
   * @param register Register index.
   * @param type     Discovered type to get.
   */
  protected void addLocalGet(int register, boolean wide) {
    addLocalGetSet(false, register, null, wide);
  }

  protected void addLocalGetSet(boolean store, int register, Type type) {
    addLocalGetSet(store, register, type, type.getSize() > 1);
  }

  /**
   * Add local set for given type.
   *
   * @param store    {@code true} when insn is a setter.
   * @param register Variable index.
   * @param type     Type of variable. {@code null} if ambiguous.
   */
  protected void addLocalGetSet(boolean store, int register, Type type, boolean wide) {
    UnresolvedVarInsn var = new UnresolvedVarInsn(wide, store, type);
    var.setLocal(regToLocal(register)); // only for now. this only works when no variables are reused.
    if (DexToASM.noResolve) {
      // For debugging
      var.setOpcode(store ? ASTORE : ALOAD);
      var.setType(Type.getObjectType("java/lang/Object"));
    } else if (type != null) {
      var.setType(type);
    }
    il.add(var);
  }
}
